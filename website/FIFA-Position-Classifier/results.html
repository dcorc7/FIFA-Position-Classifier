<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Results – David Corcoran</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="././img/gu-logo.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-f3c2ea88cadbcfb37ba28ffa2c97cfc1.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="stylesheets/styles.css">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">David Corcoran</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://corcoran.georgetown.domains/Homepage/index.html"> 
<span class="menu-text">Homepage</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Introduction</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./data_collection.html"> 
<span class="menu-text">Data Collection &amp; Preprocessing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./methods.html"> 
<span class="menu-text">Methods</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./results.html" aria-current="page"> 
<span class="menu-text">Results</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/dcorc7"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/david-corcoran-70677917a/"> <i class="bi bi-linkedin" role="img" aria-label="LinkedIn">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of Contents</h2>
   
  <ul>
  <li><a href="#neural-network-generic-position-classification" id="toc-neural-network-generic-position-classification" class="nav-link active" data-scroll-target="#neural-network-generic-position-classification">Neural Network – Generic Position Classification</a></li>
  <li><a href="#neural-network-specific-position-classification" id="toc-neural-network-specific-position-classification" class="nav-link" data-scroll-target="#neural-network-specific-position-classification">Neural Network – Specific Position Classification</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Results</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="neural-network-generic-position-classification" class="level2">
<h2 class="anchored" data-anchor-id="neural-network-generic-position-classification">Neural Network – Generic Position Classification</h2>
<p>The neural network model for classifying players into their generic football positions—attacker, midfielder, and defender—demonstrated strong performance across all evaluation metrics. The model architecture and training procedure were carefully optimized using a grid search over various hyperparameters. The best configuration consisted of <strong>three hidden layers</strong>, each with <strong>256 neurons</strong>, a <strong>dropout rate of 0.4</strong>, and the <strong>Adam optimizer</strong> with a learning rate of <strong>0.0001</strong>. This configuration yielded a <strong>best validation loss of 0.6764</strong>, as determined over 39 training epochs.</p>
<p>During training, the model’s performance steadily improved, with the validation loss decreasing from <strong>0.6933 in epoch 1</strong> to <strong>0.6722 by epoch 34</strong>, and achieving a <strong>final test loss of 0.6715</strong>. This suggests that the model not only learned meaningful representations but also generalized well to unseen data.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./img/generic_position_loss_curves.png" class="img-fluid figure-img" style="width:60.0%"></p>
<figcaption>Training and validation loss curves for the generic position model</figcaption>
</figure>
</div>
<p>The model’s classification performance was evaluated using accuracy, precision, recall, and F1 score, which were derived from the multi-class confusion matrix. The <strong>overall accuracy</strong> of the model was <strong>0.8776</strong>, indicating that nearly 88% of the predictions matched the true generic position labels. The <strong>precision (0.8772)</strong> and <strong>recall (0.8776)</strong> scores reflect a high degree of correctness and completeness in the model’s predictions, respectively. The <strong>F1 score</strong> of <strong>0.8766</strong> further confirms the balanced nature of the model’s performance.</p>
<p>The following table presents the performance metrics for the generic classification task:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Class</th>
<th>Precision</th>
<th>Recall</th>
<th>F1 Score</th>
<th>Support</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Attackers</td>
<td>0.8440</td>
<td>0.7328</td>
<td>0.7845</td>
<td>1048</td>
</tr>
<tr class="even">
<td>Defenders</td>
<td>0.9316</td>
<td>0.9456</td>
<td>0.9385</td>
<td>2406</td>
</tr>
<tr class="odd">
<td>Midfielders</td>
<td>0.8365</td>
<td>0.8727</td>
<td>0.8542</td>
<td>2357</td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong>Attackers (Class 0):</strong><br>
The model shows <strong>good precision</strong> (0.8440) but struggles with <strong>recall</strong> (0.7328), resulting in a <strong>moderate F1 score</strong> of <strong>0.7845</strong>. This indicates that while the model is accurate when predicting attackers, it fails to capture some true attackers, leading to false negatives.</p></li>
<li><p><strong>Defenders (Class 1):</strong><br>
Defenders are the best predicted class, with a <strong>high precision</strong> (0.9316) and <strong>recall</strong> (0.9456), resulting in an <strong>outstanding F1 score</strong> of <strong>0.9385</strong>. The model is both accurate and comprehensive in identifying defenders, showing strong performance in this category.</p></li>
<li><p><strong>Midfielders (Class 2):</strong><br>
The model maintains <strong>solid performance</strong> for midfielders with a <strong>precision</strong> of 0.8365 and <strong>recall</strong> of 0.8727, yielding a strong <strong>F1 score</strong> of <strong>0.8542</strong>. This indicates a balanced approach to predicting midfielders, with relatively few false positives or negatives.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./img/generic_position_confusion_matrix.png" class="img-fluid figure-img" style="width:60.0%"></p>
<figcaption>Confusion Matrix for the generic position model</figcaption>
</figure>
</div>
<p>These class-level metrics confirm that the model performs consistently across all three generic positions, though improvements could be made in enhancing recall for attackers. The <strong>macro-averaged F1 score</strong> of <strong>0.8591</strong> and <strong>weighted average F1 score</strong> of <strong>0.8766</strong> further validate the model’s robustness across the imbalanced class distribution.</p>
<p>While the current results demonstrate a high-performing model, further enhancements may be possible through the exploration of more complex architectures (e.g., attention mechanisms or residual connections) or additional input features that capture contextual positional data. Nonetheless, this neural network serves as a strong baseline for generic position classification tasks in football analytics.</p>
</section>
<section id="neural-network-specific-position-classification" class="level2">
<h2 class="anchored" data-anchor-id="neural-network-specific-position-classification">Neural Network – Specific Position Classification</h2>
<p>The neural network model developed to classify players into their specific football positions—such as central midfielders, wingers, fullbacks, and strikers—used a more complex architecture and optimization process compared to the generic model. A comprehensive grid search was conducted across multiple hyperparameter combinations, ultimately selecting the following best configuration: <strong>four hidden layers with 128 neurons each</strong>, a <strong>dropout rate of 0.4</strong>, the <strong>RMSprop optimizer</strong>, and a <strong>learning rate of 0.0001</strong>. This setup achieved a <strong>best validation loss of 1.7440</strong> after training for <strong>60 epochs</strong>.</p>
<p>The model exhibited gradual improvement during training, with the validation loss decreasing from <strong>1.8684 in epoch 1</strong> to <strong>1.7367 by epoch 55</strong>, before reaching a <strong>final test loss of 1.7404</strong>. This consistent convergence suggests effective learning, although the loss plateaued in the latter epochs, hinting at the limits of this architecture for such a fine-grained task.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./img/specific_position_loss_curves.png" class="img-fluid figure-img" style="width:60.0%"></p>
<figcaption>Training and validation loss curves for the specific position model</figcaption>
</figure>
</div>
<p>Despite successful convergence, the <strong>overall classification performance</strong> was moderate due to the increased complexity of distinguishing between nine specific player positions. The model achieved an <strong>accuracy of 0.6262</strong>, with a <strong>precision of 0.5640</strong>, <strong>recall of 0.6262</strong>, and <strong>F1 score of 0.5920</strong>. These metrics indicate that while the model can often identify the correct position, it struggles with class-specific consistency—particularly for underrepresented classes.</p>
<p>The following table summarizes the performance metrics for each class in the specific position classification task:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Class</th>
<th>Precision</th>
<th>Recall</th>
<th>F1 Score</th>
<th>Support</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0.0</td>
<td>0.8927</td>
<td>0.8955</td>
<td>0.8941</td>
<td>1254</td>
</tr>
<tr class="even">
<td>1.0</td>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0000</td>
<td>474</td>
</tr>
<tr class="odd">
<td>2.0</td>
<td>0.7932</td>
<td>0.7992</td>
<td>0.7962</td>
<td>528</td>
</tr>
<tr class="even">
<td>3.0</td>
<td>0.3514</td>
<td>0.4747</td>
<td>0.4039</td>
<td>969</td>
</tr>
<tr class="odd">
<td>4.0</td>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0000</td>
<td>145</td>
</tr>
<tr class="even">
<td>5.0</td>
<td>0.7204</td>
<td>0.8096</td>
<td>0.7624</td>
<td>541</td>
</tr>
<tr class="odd">
<td>6.0</td>
<td>0.4150</td>
<td>0.5041</td>
<td>0.4553</td>
<td>974</td>
</tr>
<tr class="even">
<td>7.0</td>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0000</td>
<td>136</td>
</tr>
<tr class="odd">
<td>8.0</td>
<td>0.7655</td>
<td>0.8924</td>
<td>0.8241</td>
<td>790</td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong>Center Backs (Class 0):</strong><br>
The model performed exceptionally well for center-backs with high <strong>precision</strong> (0.8927) and <strong>recall</strong> (0.8955), resulting in an <strong>F1 score</strong> of <strong>0.8941</strong>. This suggests that the model reliably identifies this position with few false positives and false negatives.</p></li>
<li><p><strong>Center Midfielders (Class 1):</strong><br>
The model failed to classify center midfielders, resulting in a <strong>precision</strong> and <strong>recall</strong> of 0.0000. This could be due to the underrepresentation of left-backs in the training data or insufficient discriminative features in the input data for this role.</p></li>
<li><p><strong>Left Backs (Class 2):</strong><br>
Left-backs were classified well with <strong>precision</strong> (0.7932) and <strong>recall</strong> (0.7992), yielding a strong <strong>F1 score</strong> of <strong>0.7962</strong>. This indicates that the model can reliably classify these players.</p></li>
<li><p><strong>Left Midfielders (Class 3):</strong><br>
Performance for Left midfielders was moderate, with a <strong>F1 score</strong> of <strong>0.4039</strong>. The model exhibited weaker results in both <strong>precision</strong> and <strong>recall</strong>, which may be due to the complex nature of this position, which often overlaps with other roles.</p></li>
<li><p><strong>Left Wingers (Class 4):</strong><br>
Left wingers were poorly classified with <strong>precision</strong> and <strong>recall</strong> both at 0.0000. The lack of success here points to a data imbalance or feature overlap causing difficulty in learning the distinguishing traits of defensive midfielders.</p></li>
<li><p><strong>Right Backs (Class 5):</strong><br>
The model performed well with right backs, scoring <strong>precision</strong> (0.7204), <strong>recall</strong> (0.8096), and an <strong>F1 score</strong> of <strong>0.7624</strong>, indicating strong classification results for this position.</p></li>
<li><p><strong>Right Midfielders (Class 6):</strong><br>
The model’s <strong>F1 score</strong> for right midfielders was <strong>0.4553</strong>, with moderate performance in both <strong>precision</strong> and <strong>recall</strong>. Improving precision would help reduce false positives for this position.</p></li>
<li><p><strong>Right Wingers (Class 7):</strong><br>
Similar to other underrepresented roles, right wingers had a <strong>precision</strong> and <strong>recall</strong> of 0.0000. This suggests the model was unable to effectively identify this position, likely due to insufficient data or feature ambiguity.</p></li>
<li><p><strong>Strikers (Class 8):</strong><br>
The model performed strongly with strikers, achieving an <strong>F1 score</strong> of <strong>0.8241</strong>. Both <strong>precision</strong> (0.7655) and <strong>recall</strong> (0.8924) were high, showing that the model accurately identified this attacking role.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./img/specific_position_confusion_matrix.png" class="img-fluid figure-img" style="width:60.0%"></p>
<figcaption>Confusion Matrix for the specific position model</figcaption>
</figure>
</div>
<p>Overall, while the model demonstrated strong performance for certain positions, such as center backs (Class 0) and strikers (Class 8), there is a significant imbalance in how it classifies less-represented positions, like left midfielders (Class 3) and right wingers (Class 7). These results highlight areas for potential improvement, such as data augmentation, class balancing, or incorporating positional embeddings into the model.</p>
<p>The macro-averaged F1 score of 0.4595 reflects the variance in performance across classes, while the weighted average F1 score of 0.5920 shows that the model performs better on the more prevalent classes. These results indicate that while the model captures positional patterns for well-represented roles, like center backs and strikers, it struggles with niche or overlapping classes such as center midfielders (Class 1) and left wingers (Class 4).</p>
<p>Future improvements could involve class balancing techniques, positional embeddings, or sequence-aware models to capture tactical roles more dynamically. Nonetheless, the current model offers a useful first step in fine-grained player role prediction.</p>


</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>